use std::collections::BTreeMap;
use std::fs::File;
use std::io::{self, BufRead, BufWriter, Write};

fn emit_convs(
    tn: &str,
    d: &BTreeMap<String, String>,
    mask: Option<&str>,
    outfile: &mut BufWriter<File>,
) -> std::io::Result<()> {
    let mut nums: Vec<&String> = d.keys().collect();
    nums.sort();

    let tryfrom_u8_str = nums
        .iter()
        .map(|n| format!("\t\t{} => Ok(Self::{}),\n", n, d.get(*n).unwrap()))
        .collect::<String>();
    let from_enum_str = nums
        .iter()
        .map(|n| format!("\t\t{}::{} => {},\n", tn, d.get(*n).unwrap(), n))
        .collect::<String>();

    let tryfrom_u8_pattern: &str = &format!(
        r#"impl TryFrom<u8> for {} {{
    type Error = Iso7816Error;
    fn try_from(value: u8) -> Result<Self, Self::Error> {{
        match value{} {{
        {}
        _ => Err(Self::Error::ValueError)
        }}
    }}
}}

    "#,
        tn,
        mask.map(|m| format!(" & {}", m)).unwrap_or_default(),
        tryfrom_u8_str,
    );

    let from_enum_pattern: &str = &format!(
        r#"impl From<{}> for u8 {{
    fn from(value: {}) -> u8 {{
        match value {{
        {}
        }}
    }}
}}

    "#,
        tn, tn, from_enum_str,
    );

    let bitor_impl: &str = &format!(
        r#"impl<T> BitOr<T> for {}
where
    T: Into<u8>,
{{
    type Output = u8;
    
    fn bitor(self, rhs: T) -> u8 {{
        let a: u8 = self.into();
        let b: u8 = rhs.into();
        a | b
    }}
}}

    "#,
        tn,
    );

    outfile.write_all(format!("{}", tryfrom_u8_pattern,).as_bytes())?;
    outfile.write_all(format!("{}", from_enum_pattern).as_bytes())?;
    outfile.write_all(format!("{}", bitor_impl).as_bytes())?;
    Ok(())
}

fn process_file(file_path: &str, out_path: &str) -> std::io::Result<()> {
    let infile = File::open(file_path)?;
    let mut outfile = BufWriter::new(File::create(out_path)?);

    outfile.write_all(b"// THIS FILE IS AUTOGENERATED -- DO NOT EDIT\n")?;
    outfile.write_all(b"use core::ops::BitOr;\n")?;

    let mut tname: Option<String> = None;
    let mut mask: Option<String> = None;
    let mut v_rev: BTreeMap<String, String> = BTreeMap::new();

    for ln_res in std::io::BufReader::new(infile).lines() {
        let ln = ln_res?;
        if ln.starts_with("pub enum") {
            let fields_slice: Vec<_> = ln.split(' ').collect();
            let fields: Vec<_> = fields_slice.iter().filter(|s| !s.is_empty()).collect();
            tname = Some(fields[2].to_owned().to_owned());
            v_rev.clear();
            mask = None;
        } else if let Some(_tn) = &tname {
            if ln.starts_with("    /* mask:") {
                mask = Some(ln[12..ln.len() - 3].trim().to_owned());
            } else if ln.contains('=') {
                let parts: Vec<_> = ln.split('=').collect();
                let fn_name = parts[0].trim().to_owned();
                let vn_parts: Vec<_> = parts[1].trim().split(',').collect();
                let vn = vn_parts[0].trim().to_owned();
                v_rev.insert(vn, fn_name);
            } else if ln.starts_with('}') {
                emit_convs(
                    tname.as_ref().unwrap(),
                    &v_rev,
                    mask.as_deref(),
                    &mut outfile,
                )?;
                tname = None;
            } else {
                outfile
                    .write_all(
                        format!(
                            "// not emitting {}, bogus line: {}\n",
                            tname.as_ref().unwrap(),
                            ln
                        )
                        .as_bytes(),
                    )
                    .unwrap();
                // suppress emitting this enum, probably not meant to be?
                tname = None;
            }
        }
    }
    Ok(())
}

fn main() -> io::Result<()> {
    println!("cargo:rerun-if-changed=src/types.rs");
    println!("cargo:rerun-if-changed=src/se050.rs");
    println!("cargo:rerun-if-changed=build.rs");

    let input_file = "src/se050.rs";
    let output_file = "src/se050_convs.rs";
    process_file(input_file, output_file)?;

    let input_file1 = "src/types.rs";
    let output_file1 = "src/types_convs.rs";
    process_file(input_file1, output_file1)?;

    Ok(())
}
